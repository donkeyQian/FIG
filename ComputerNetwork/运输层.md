 ## 概述

物理层、数据链路层、网络层共同解决了将主机通过异构网络互连起来的问题，实现了从主机到主机之间的通信。

但实际上在计算机网络中进行的通信的`真正实体`是位于通信两端主机中的`进程`。

如何为运行在不同主机上的应用进程提供直接的通信服务是运输层的任务，运输层协议又称为`端到端协议`。

![](../image/Pasted%20image%2020221204234034.png)

运输层向高层应用屏蔽了下面网络核心的细节（如网络拓扑、所采用的路由选择协议等），它使应用进程看见的就好像是在两个运输层实体之间有一条端到端的逻辑通信信道。

根据应用需求的不同，因特网的运输层为应用层提供了两种不同的运输协议，即面向连接的TCP 和无连接的 UDP，这两种协议就是本章要讨论的主要内容。

## 运输层端口号、复用与分用的概念

### 端口号

* 运行在计算机上的进程使用`进程标识符PID`来标志。

* 因特网上的计算机并不是使用统一的操作系统，`不同的操作系统`（windows,Linux,Mac OS)又使用`不同格式的进程标识符`。

* 为了使运行不同操作系统的计算机的应用进程之间能够进行网络通信，就必须`使用统一的方法对TCP/IP体系的应用进程进行标识`。

* TCP/IP体系的运输层使用端口号来区分应用层的不同应用进程。
    * 端口号使用16比特表示，取值范围0~65535;
        * `熟知端口号`：0~1023，IANA把这些端口号指派给了TCP/IP体系中最重要的一些应用协议，例如：FTP使用21/20,HTTP使用80，DNS使用53。
        * `登记端口号`：1024~49151，为没有熟知端口号的应用程序使用。使用这类端口号必须在IANA按照规定的手续登记，以防止重复。例如：Microsoft RDP 微软远程桌面使用的端口是3389。
        * `短暂端口号`：49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。

* `端口号只具有本地意义`，即端口号只是为了`标识本计算机应用层中的各进程`，在因特网中,`不同计算机中的相同端口号是没有联系的`。

### 发送方的复用和接受方的分用

操作系统的`多个进程`（这里一个端口代表一个进程）`利用一个运输层协议`（或者称为运输层端口）`发送数据称为复用`。同理，接收时称为分用。

![](../image/Pasted%20image%2020221204234711.png)

### 熟知端口号

UDP 协议的[[网络层.md#^ccc8a4|协议字段]]为17，TCP [[网络层.md#^ccc8a4|协议字段]]为 6。

![](../image/Pasted%20image%2020221204234726.png)

## UDP和TCP的对比

![](../image/Pasted%20image%2020221204234742.png)
![](../image/Pasted%20image%2020221204234754.png)
![](../image/Pasted%20image%2020221204234837.png)
![](../image/Pasted%20image%2020221204234829.png)
![](../image/Pasted%20image%2020221204234852.png)
![](../image/Pasted%20image%2020221204234900.png)

## TCP的流量控制

* 一般来说，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。

* 所谓`流量控制`（flow control)就是`让发送方的发送速率不要太快，要让接收方来得及接收`。

* 利用`滑动窗口`机制可以很方便地在TCP连接上实现对发送方的流量控制。信息的`接受方`会在报文确认信息中附带`流量控制信息`，来`控制`发送方数据`拥塞窗口的大小`。

### 流量控制的基本工作过程

![](../image/Pasted%20image%2020221204235459.png)

* TCP 的流量控制`允许将拥塞窗口控制为0`，`发送方`收到这个信息后会`暂停发送数据报`，等待流量控制重新放开
    * 发送方暂停发送数据报的同时会启动一个`持续计时器`，如果超时后还没有收到新的流量控制信息或新的流量控制信息在链路中丢失，发送方会发送一个数据部分大小为1字节的`零窗口探测报文`（在？），接收方在收到这个报文后，会对这个报文进行正常的响应并附带上最新的流量控制信息（在）。
    * 将流量控制为0, 并不意味着接收方不会接收任何来自发送方的信息，有一些紧急报文是必须要接收的，例如上文中的零窗口探测报文。

![](../image/Pasted%20image%2020221205000417.png)

## TCP的拥塞控制

* 在某段时间内，若`对网络中某一资源的需求超过了该资源所能提供的可用部分`，网络性能就要变坏。这种情况就`叫做拥塞`。
 
* 在计算机网络中的链路容量（带宽）、交换节点中的缓存和处理机等，都是网络的资源。

* 若出现拥塞而不控制，整个网络的吞吐量将随输入负荷的增大而下降。

![](../image/Pasted%20image%2020221205000517.png)

* 如果没有拥塞控制，当陷入轻度拥塞后，随着输入负载的提高，吞吐量并没有提高，网络中的拥塞情况进一步提高，直到最后吞吐量为0，陷入死锁。

### TCP的四种拥塞控制算法

* 发送方维护一个叫做`拥塞窗口 cwnd` 的状态变量，其值`取决于网络的拥塞程度`，并且`动态变化`。
    * 拥塞窗口`cwnd的维护原则`：只要网络`没有出现拥塞`，`拥塞窗口`就再`增大`一些;但只要网络`出现拥塞`，`拥塞窗口就减少`一些。
    * 判断出现`网络拥塞的依据`：没有按时收到应当到达的确认报文（即`发生超时重传`)。

* 发送方将拥塞窗口作为发送窗口swnd,即swnd = cwnd。

* 维护一个慢开始门限`ssthresh`状态变量：
    * 当cwnd < ssthresh时，使用慢开始算法;
    * 当cwnd > ssthresh时，停止使用慢开始算法而改用拥塞避免算法;
    * 当cwnd = ssthresh时，既可使用慢开始算法，也可使用拥塞避免算法。

#### 慢开始算法
>“慢开始”是指一开始向网络注入的报文段少，并不是指拥塞窗口 cwnd 增长速度慢。

* 慢开始算法，发送方`每一个发送轮次`会将拥塞窗口`增大`为原来的`两倍`，直到拥塞窗口大小大于或等于慢开始门限。

* 如下图所示，刚开始时发送方的拥塞窗口为1，在没有发生拥塞的情况下，拥塞窗口随着轮次的增加指数形的向上增长，直到拥塞窗口大于等于慢开始门限值。![](../image/Pasted%20image%2020221205000933.png)
#### 拥塞避免算法
>拥塞避免并非值完全能够避免拥塞，而是值在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。

* 拥塞避免算法在没有发生超时重传的情况下，发送方在`每一个轮次`会将拥塞窗口大小值`+1`。

![](../image/Pasted%20image%2020221205001100.png)

* 当发送方触发`超时重传`时，拥塞避免算法会判断网络此时很可能发生了拥塞，进行以下工作：
    1.  将`慢开始门限大小`设置为`拥塞窗口大小的一半`
    2.  将`拥塞窗口`大小设置为`1`，`重新执行慢开始算法`

![](../image/Pasted%20image%2020221205001107.png)

#### 快重传

* 所谓快重传，就是使发送方`尽快进行重传`，而`不是等超时重传计时器超时再重传`。
    * 要求接收方不要等待自己发送数据时才进行捎带确认，而是要`立即发送确认`;
    * 即使收到了失序的报文段也要立即发出对已收到的报文段的`重复确认`。
    * 发送方一旦`收到3个连续的重复确认`，就将相应的报文段`立即重传`，而不是等该报文段的超时重传计时器超时再重传。
    * 对于个别丢失的报文段，发送方不会出现超时重传，也就不会误认为出现了拥塞（进而降低拥塞窗口cwnd为1）。使用快重传可以`使整个网络的吞吐量提高约20%`。

![](../image/Pasted%20image%2020221205002710.png)

#### 快恢复

* 发送方一旦`收到3个重复确认`，就知道现在只是丢失了个别的报文段。于是不启动慢开始算法，而`执行快恢复算法`;
    * `发送方将慢开始门限ssthresh值和拥塞窗口cwnd值调整为当前窗口的一半;开始执行拥塞避免算法`。
    * 也有的快恢复实现是把快恢复开始时的拥塞窗口cwnd值再增大一些，即等于新的ssthresh+ 3。
        * 既然发送方收到3个重复的确认，就表明有3个数据报文段已经离开了网络;
        * 这3个报文段不再消耗网络资源而是停留在接收方的接收缓存中;
        * 可见现在网络中不是堆积了报文段而是减少了3个报文段。因此可以适当把拥塞窗口扩大些。

### 举例

![](../image/Pasted%20image%2020221205002859.png)

## TCP超时重传时间的选择

TCP 超时重传的时间选择问题是TCP 最复杂的问题之一

超时重传时间缩写为 RTO

* 如果 RTO `小于`[往返时间](计算机网络概述.md#^548bc3) RTT，就会造成`不必要的重传，使网络负荷加大 `
* 如果 RTO `远大于`往返时间 RTT，就会`使网络的空闲时间增大，降低了传输效率`
* 综合上述两种情况，我们可以得出结论，超时重传时间 RTO 的值应该设置成`略大于往返时间 RTT 的值`。

*  然而，实际中的因特网环境是很复杂的，相同 TCP 连接的前后两次数据传输经过的网络链路可能不同，这两次数据传输的RTT 自然也就不同。![1|500](../image/Pasted%20image%2020221205143652.png)

### 加权平均往返时间

根据上文，我们`不能直接使用某次测量得到的RTT样本来计算超时重传时间RTO`。

* 在现实网络环境中，我们利用每次测量得到的RTT样本，计算`加权平均往返时间RTT`<sub>s</sub>(又称为平滑的往返时间） 。
    1. RTT<sub>S1</sub> = RTT<sub>1</sub>
    2. 新的 RTT<sub>S</sub>  =(1 – a) x 旧的 RTT<sub>S</sub>+ a x 新的 RTT 样本
    3. 在上式中，0≤ a<1:
        * 若a很接近于0，则新 RTT 样本对RTTs 的影响不大;
        * 若a很接近于1，则新 RTT 样本对RTTs 的影响较大;
        * 已成为建议标准的 *RFC6298* 推荐的0值为1/8，即0.125。

* 用这种方法得出的加权平均往返时间RTTs就比测量出的RTT值更加平滑。

* 显然，超时重传时间RTO应略大于加权平均往返时间RTTs。

* *RFC6298* 建议使用下式计算超时重传时间 RTO:
    * RTO = RTTs + 4 x RTT<sub>D</sub>（RTT偏差的加权平均 RTT<sub>D</sub> ）
        * RTTs 的计算方式如上文所示
        * RTT<sub>D</sub> 的计算方式为：
            * RTT<sub>D1</sub> = RTT<sub>1</sub> ÷ 2
            * 新的RTT<sub>D</sub>=(1 - β) × 旧的RTT + β x | RTTs -  新的RTT样本 | 
                * 0 ≤ β  < 1已成为建议标准的 *RFC6298* 推荐的 β 值为1/4，即 0.25。

### 超时重传对 RTT 测量的影响

经过上面的学习，我们知道了 RTO 的加权计算公式，但实际上这种方式是很依赖 RTT 的准确性的，在实际网络环境中，RTT 的测量会受到超时重传和分组丢失的影响。

如下图所示，一旦发生`超时重传`，发送方就`无法分辨`后面收到的确认信息是对重传报文的确认还是对原报文的确认。
![](../image/Pasted%20image%2020221205145741.png)

* 针对出现超时重传时无法测准往返时间RTT的问题，*Karn* 提出了一个算法：`在计算加权平均往返时间 RTTs 时，只要报文段重传了，就不采用其往返时间 RTT 样本`。也就是出现重传时，不重新计算RTTs，进而超时重传时间RTO也不会重新计算。

* 这又引起了新的问题。设想出现这样的情况：报文段的时延突然增大了很多，并且之后很长一段时间都会保持这种时延。因此在原来得出的重传时间内，不会收到确认报文段。于是就重传报文段。但根据Karn算法，不考虑重传的报文段的往返时间样本。这样，超时重传时间就无法更新。这会导致报文段反复被重传。
* 因此，要对`Karn算法进行修正`。方法是：报文段`每重传一次`，就把超时重传时间  `RTO增大一些`。典型的做法是将新RTO的值取为旧RTO值的`2倍`。

## TCP可靠传输的实现

TCP 基于`以字节为单位的滑动窗口`来实现可靠传输。

实际上就是[选择重传协议SR（Selective Request）](数据链路层.md#选择重传协议SR（Selective%20Request）)，但在实际执行中，发送窗口和接收窗口的大小都要受到流量控制和拥塞控制算法的影响。

### 滑动窗口实现
>以下实现忽略拥塞控制对可靠传输的影响

* 发送方会根据接收方确认报文段中的信息构造自己的发送窗口，具体实现步骤为：将`发送窗口大小`设置与接收方的接收窗口`一致`，`起始位置`为接受到的 `ack` 序号。
    * 接收方确认报文段中的信息：
        * rwnd：接收方告诉发送方自己的接收窗口大小
        * ack ：接收方希望收到的下一个字节的序号，这意味着这个序号之前的字节已经全都接收到了
    * 发送方`发送分组的速度`与计算机的[发送速率](计算机网络概述.md#^25219e)有关，`和发送窗口大小无关`
    * `发送窗口的大小和起始位置会随着接受方的确认信息不断变化`

* 接受方在接收数据时，只能对按序到达的分组做出确认。
    * 如下如所示，发送方发送了 31 - 41 号的分组，接受方暂时只收到了 32 和 33号分组，31 号分组此时有可能已经在网络中被丢弃或在某处滞留，因此，接受方只能对 31 号分组做出[重复确认](运输层.md#快重传)，提醒发送方自己没有按序收到31号分组， ![](../image/Pasted%20image%2020221205164224.png)

* 虽然发送方的发送窗口是根据接收方的接收窗口设置的，但在同一时刻，`发送方的发送窗口并不总是和接方的接收窗口一样大`。
    * 网络传送窗口值需要经历一定的时间滞后，并且这个时间还是不确定的。
    * 发送方还可能根据网络当时的拥塞情况适当减小自己的发送窗口尺寸。

* 对于`不按序到达的数据`应如何处理，TCP并`无明确规定`。
    * 如果接收方把不按序到达的数据一律丢弃，那么接收窗口的管理将会比较简单，但这样做对网络资源的利用不利,因为发送方会重复传送较多的数据。
    * TCP`通常`对不按序到达的数据是先`临时存放`在接收窗口中，等到字节流中所缺少的字节收到后，`再按序交付`上层的应用进程。

* TCP要求接收方`必须有累积确认和捎带确认机制`，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。
    * `接收方不应过分推迟发送确认`，否则会导致发送方不必要的超时重传，这反而浪费了网络的资源。TCP标准规定，确认推迟的时间不应超过0.5秒。若收到一连串具有最大长度的报文段，则必须每隔一个报文段就发送一个确认 *RFC 1122*。
    * 捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。

* `TCP的通信是全双工通信`。通信中的每一方都在发送和接收报文段。因此，每一方都有自己的发送窗口和接收窗口。在谈到这些窗口时，一定要弄清楚是哪一方的窗口。

## TCP 的运输连接管理——TCP的连接建立

* TCP 是面向连接的协议，它基于运输连接来传送 TCP 报文段

* TCP运输连接的建立和释放是每一次面向连接的通信中必不可少的过程。

* TCP 运输连接有以下三个阶段：
    1. 建立TCP连接
    2. 数据传送
    3. 释放TCP连接
![TCP传输流程|300](../image/Pasted%20image%2020221205174245.png)
* TCP 运输连接管理就是使运输连接的建立和释放都能正常的运行

* TCP的连接建立要解决以下三个问题:
    1. 使TCP双方能够`确知对方`的`存在`;
    2. 使TCP双方能够`协商`一些`参数`（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）;
    3. 使TCP双方能够对`运输实体资源`（如缓存大小、连接表中项目等）进行`分配`。

### TCP 的三次握手

* TCP 的连接是有客户进程发起的

1. TCP 客户进程向TCP 服务端进程`发送一个 TCP 连接请求报文段`，客户进程状态由 CLOSED（关闭） 转为 `SYN-SEND`（同步已发送）
    * 连接请求报文信息：
        * [SYN](运输层.md#^c7ede4) = 1：表示这是一个TCP 连接请求报文
            * `TCP 规定 SYN 值为 1 的报文段不能携带数据`
        * [seq](运输层.md#^a92f34) = x，x 是TCP 客户进程所选择的初始字节序号
2. TCP 服务端进程如果同意与客户端建立连接，则会向客户进程`发送 TCP 连接请求确认报文`段，并进入 `SYN-RCVD`（同步已接收）状态
    * 连接请求确认报文信息：
        * [SYN](运输层.md#^c7ede4) = 1：表示这是一个连接请求确认报文
        * [ACK](运输层.md#^94ef79) = 1：表示这是对上一条报文段的确认
        * [seq](运输层.md#^a92f34) = y：y 是TCP 服务进程所选择的初始字节序号
        * [ack](运输层.md#^b7638a) = x+1：表示对确认收到的报文段序号为x，服务进程期望收到的下一个报文段序号为 x + 1
3. 客户进程收到服务进程的连接请求确认报文后，还要向TCP 服务进程`发送一个普通的TCP确认报文段`，并进入 `ESTABLISHED `（连接已建立）状态。
    * TCP 确认报文段信息：
        * [ACK](运输层.md#^94ef79) = 1：表明这是一个确认报文
        *  [seq](运输层.md#^a92f34) = x + 1：表明当前报文的序号
        * [ack](运输层.md#^b7638a) = y + 1：表明自己确认的是哪一个报文
4. 服务进程收到客户进程发送的普通TCP 确认报文段，进入 `ESTABLISHED `（连接已建立）状态。
![](../image/Pasted%20image%2020221205182454.png)

#### TCP 为何需要三次握手？

建立连接的双反只需要两次握手就能知晓对方的存在，为什么还需要三次握手呢？能否将流程简化至两次握手？

理论上来说这样做是可行的，如果少了中间的同步状态，双方同样可以建立连接，但是在实际网络中，分组并不是次次都能准时到达目的地址，如果客户进程发送的第一个建立连接请求在网络中滞留，导致客户进程超时重发，就有可能导致图中的问题：
![](../image/Pasted%20image%2020221205183508.png)
如果少了客户进程给服务进程发送一个TCP 确认报文的第三次握手，那么服务进程可能会以为双反已经建立了连接，做无用的等待。

### TCP的四次挥手

* TCP 的终止连接由客户进程发起

1. `客户进程`向服务进程`发送一个连接释放报文`，同时，自身状态由ESTABLISHED （连接已建立）转为 `FIN-WAIT-1`（终止等待1）状态。
    * 连接释放报文信息：
        * [FIN](运输层.md#^d229fa) = 1，[ACK](运输层.md#^94ef79) = 1
            * 表示这是一个TCP 连接释放报文
            * TCP 规定 FIN 值为 1 的报文即使数据部分为空也需要消耗一个序号
        * [seq](运输层.md#^a92f34) = u：u 为客户进程已发送数据的最后一个字节序号 + 1，表示当前报文的序号
        * [ack](运输层.md#^b7638a) =  v：v 为客户进程接收到的数据的最后一个字节序号 + 1，表示对之前报文的确认
2. TCP `服务进程`在收到连接释放报文后，会发送一个`普通的确认报文`，并转为 `CLOSE-WAIT`（关闭等待） 状态，同时通知高层应用，客户端要断开与自己的连接。
    * 确认报文信息：
        * ACK = 1，seq = v，ack = u + 1
    * 这个阶段已经进入了半关闭状态，但是如果服务进程还有数据待发送，客户进程还是要接收。也就是说`从服务进程到客户进程的这个方向还没有关闭`。
3. TCP `服务进程`在发送完待发送数据后，会向客户进程发送一个`连接释放报文`，同时自身进入 `LAST-ACK`  （最后确认）状态。
    * 连接释放报文信息：
        * FIN = 1，ACK = ， seq = w，ack = u + 1
            * seq 值为 w 是因为服务进程在 CLOSE-WAIT 状态可能还会发送一些数据，w = v + 最后确认状态内发送的字节总数
4. `客户端收`到服务端的连接释放报文后，对该报文进行确认，发送一个`普通的确认报文`，同时自身进入`TIME-WAIT`（时间等待）状态。
    * 确认报文信息：
        * ACK = 1，seq = u + 1，ack= w + 1
    * 这一状态的持续时间为 2 MSL
        * MSL (Maximum Segment Lifetime)意思是最长报文段寿命，*RFC793*  建议为2分钟。
5. 服务进程收到客户端的确认报文后，进入 `CLOSE`（关闭）状态。

![](../image/Pasted%20image%2020221205190921.png)

#### 客户进程为什么要等2MSL 的时长才能进入关闭状态

原因：
1. 如果客户进程对服务进程的连接释放报文的确认报文在网络中丢失了，那服务进程在重传计时器超时之后，就会重传连接释放报文，如果此时客户进程已经是关闭的状态，那服务进程就会不停的超时重发。
2. 等待2MSL 的时间，可以使当前连接的报文在网络中超时消失，这样下一个新的 TCP 连接就不会受到旧连接的干扰
![](../image/Pasted%20image%2020221205222554.png)

### TCP的保活计时器

保活计时器用来确保当客户端出现故障或其他情况，无法与服务器继续通信时，服务器能及时发现。
![](../image/Pasted%20image%2020221205223527.png)
* TCP服务器进程每收到一次TCP客户进程的数据，就重新设置并启动`保活计时器`（2小时定时）。
* 若保活计时器定时周期内未收到TCP客户进程发来的数据，则`当保活计时器到时后，TCP服务器进程就向TCP客户进程发送一个探测报文段`，以后则每`隔75秒钟`发送一次。若一连`发送10个`探测报文段后仍无TCP客户进程的响应，TCP服务器进程就认为TCP客户进程所在主机出了故障,接着就`关闭这个连接`。

## TCP报文段的首部格式

* 为了实现可靠传输，TCP采用了`面向字节流`的方式。

* 但TCP在发送数据时，是从发送缓存取出一部分或全部字节并给其添加一个首部使之成为`TCP报文段`后进行发送。
    * 一个TCP报文段由首部和数据载荷两部分构成;
    * TCP的全部功能都体现在它首部中各字段的作用。

![TCP|400x350](../image/Pasted%20image%2020221206011557.png)

TCP 报文的首部格式与[IPv4数据报的首部格式](网络层.md#IPv4数据报的首部格式)类似，同样是以 20 字节的 固定首部 + 最大 40字节的拓展首部组成。
![](../image/Pasted%20image%2020221206020620.png)

* 源端口号
    * 占 16bit，写入源端口号，用来`标识发送该TCP报文段的应用进程`。
* 目的端口号
    * 占 16bit，写入源端口号，用来`标识接收该TCP报文段的应用进程`。
* 序号 ^a92f34
    * 占32比特，取值范围 0 - 2<sup>32</sup>-1，序号增加到最大值后，下一个序号就又回到0。`指出本TCP报文段数据载荷的第一个字节的序号`。
    * 举例：![举例|500](../image/Pasted%20image%2020221206012721.png)
* 确认号 ^b7638a
    * 占32比特，取值范围 0 - 2<sup>32</sup>-1，确认号增加到最后一个后，下一个确认号就又回到0。
    * `指出期望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，同时也是对之前收到的所有数据的确认`。
    * 若确认号=n，则表示到序号 n-1 为止的数据已经全部正常接收，期望接收序号为 n 的数据。
* 确认位ACK ^94ef79
    * 取值为1时确认号字段才有效；取值为0时确认号字段无效。
    * `TCP规定，在连接建立后所有传送的TCP报文段都必须把ACK置1`。
* 数据偏移
    * 占4比特，并以4字节为单位。
        * 该值为(0111)<sub>2</sub>时，十进制值为7，表示偏移量为 7 x 4 = 28 字节
    * `用来指出TCP报文段的数据载荷部分的起始处距离TCP报文段的起始处有多远`。
    * 这个字段实际上是指出了TCP报文段的首部长度。
        * 首部固定长度为20字节，因此数据偏移字段的最小值为(0101)<sub>2</sub>
        * 首部最大长度为60字节，因此数据偏移字段的最大值为(1111)<sub>2</sub>
* 保留
    * 占6比特，保留为后续使用，目前为全0。
* 窗口
    * 占16比特，以字节为单位。`指出发送本报文段的一方的接收窗口`。
    * 窗口值作为接收方让发送方设置其发送窗口的依据。
    * 这是以接收方的接收能力来控制发送方的发送能力，称为[流量控制](运输层.md#TCP的流量控制)
    * `发送窗口`还应该参考拥塞窗口，也就是说`从流量控制窗口和拥塞控制窗口中取小者`。
* 校验和
    * 占16比特，检查范围包括TCP报文段的首部和数据载荷两部分。
    * 在计算校验和时，要在TCP报文段的前面加上12字节的伪首部。
* SYN ^c7ede4
    * 同步标志位，在TCP建立连接时用来`同步序号`。
* FIN ^d229fa
    * 终止标志位，用来`释放TCP连接`。
* RST
    * 复位标志位，用来`复位TCP连接`。
    * 当RST=1时，表明TCP连接出现了异常，必须释放连接，然后再重新建立连接。
    * RST 置1还可以用来拒绝一个非法的报文段或者拒绝打开一个TCP连接。
* PSH
    * `推送标志位`，接收方的TCP收到该标志位为1的报文段会尽快上交应用进程,而不必等到接收缓存都填满后再向上交付。
* URG
    * 紧急标志位，取值为1时紧急指针字段有效；取值为0时紧急指针字段无效。
* 紧急指针
    * 占16比特，以字节为单位，用来`指明紧急数据的长度`。
    * 当发送方有紧急数据时，可将紧急数据插队到发送缓存的最前面，并立刻封装到一个TCP报文段中进行发送。紧急指针会指出本报文段数据载荷部分包含了多长的紧急数据，紧急数据之后是普通数据。
    * 接收方接收到紧急数据后，会直接根据紧急指针标明的紧急数据长度获取紧急数据，而不用在接收缓存中排队
* 选项（长度可变）
    * 最大报文段长度MSS选项:TCP报文段数据载荷部分的最大长度。
    * 窗口扩大选项：为了扩大窗口（提高吞吐率）。
    * 时间戳选项:
        * 用来计算往返时间RTT
        * 用于处理序号超范围的情况，又称为防止序号绕回PAWS。
    * 选择确认选项
* 填充
    * 由于选项的长度可变，因此使用填充来`确保报文段首部能被4整除`(因为数据偏移字段，也就是首部长度字段，是以4字节为单位的）。